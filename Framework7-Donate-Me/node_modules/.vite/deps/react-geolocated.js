import {
  require_react
} from "./chunk-F54VIFIN.js";
import {
  __commonJS
} from "./chunk-BHN6OJC3.js";

// node_modules/react-geolocated/dist-modules/index.js
var require_dist_modules = __commonJS({
  "node_modules/react-geolocated/dist-modules/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useGeolocated = void 0;
    var react_1 = require_react();
    function useGeolocated(config = {}) {
      const { positionOptions = {
        enableHighAccuracy: true,
        maximumAge: 0,
        timeout: Infinity
      }, isOptimisticGeolocationEnabled = true, userDecisionTimeout = void 0, suppressLocationOnMount = false, watchPosition = false, geolocationProvider = typeof navigator !== "undefined" ? navigator.geolocation : void 0, onError, onSuccess } = config;
      const userDecisionTimeoutId = (0, react_1.useRef)(0);
      const isCurrentlyMounted = (0, react_1.useRef)(true);
      const watchId = (0, react_1.useRef)(0);
      const [isGeolocationEnabled, setIsGeolocationEnabled] = (0, react_1.useState)(isOptimisticGeolocationEnabled);
      const [coords, setCoords] = (0, react_1.useState)();
      const [timestamp, setTimestamp] = (0, react_1.useState)();
      const [positionError, setPositionError] = (0, react_1.useState)();
      const cancelUserDecisionTimeout = (0, react_1.useCallback)(() => {
        if (userDecisionTimeoutId.current) {
          window.clearTimeout(userDecisionTimeoutId.current);
        }
      }, []);
      const handlePositionError = (0, react_1.useCallback)((error) => {
        cancelUserDecisionTimeout();
        if (isCurrentlyMounted.current) {
          setCoords(() => void 0);
          setIsGeolocationEnabled(false);
          setPositionError(error);
        }
        onError === null || onError === void 0 ? void 0 : onError(error);
      }, [onError, cancelUserDecisionTimeout]);
      const handlePositionSuccess = (0, react_1.useCallback)((position) => {
        cancelUserDecisionTimeout();
        if (isCurrentlyMounted.current) {
          setCoords(position.coords);
          setTimestamp(position.timestamp);
          setIsGeolocationEnabled(true);
          setPositionError(() => void 0);
        }
        onSuccess === null || onSuccess === void 0 ? void 0 : onSuccess(position);
      }, [onSuccess, cancelUserDecisionTimeout]);
      const getPosition = (0, react_1.useCallback)(() => {
        if (!geolocationProvider || !geolocationProvider.getCurrentPosition || !geolocationProvider.watchPosition) {
          throw new Error("The provided geolocation provider is invalid");
        }
        const funcPosition = (watchPosition ? geolocationProvider.watchPosition : geolocationProvider.getCurrentPosition).bind(geolocationProvider);
        if (userDecisionTimeout) {
          userDecisionTimeoutId.current = window.setTimeout(() => {
            handlePositionError();
          }, userDecisionTimeout);
        }
        watchId.current = funcPosition(handlePositionSuccess, handlePositionError, positionOptions);
      }, [
        geolocationProvider,
        watchPosition,
        userDecisionTimeout,
        handlePositionError,
        handlePositionSuccess,
        positionOptions
      ]);
      (0, react_1.useEffect)(() => {
        if (!suppressLocationOnMount) {
          getPosition();
        }
        return () => {
          cancelUserDecisionTimeout();
          if (watchPosition && watchId.current) {
            geolocationProvider === null || geolocationProvider === void 0 ? void 0 : geolocationProvider.clearWatch(watchId.current);
          }
        };
      }, []);
      return {
        getPosition,
        coords,
        timestamp,
        isGeolocationEnabled,
        isGeolocationAvailable: Boolean(geolocationProvider),
        positionError
      };
    }
    exports.useGeolocated = useGeolocated;
  }
});

// dep:react-geolocated
var react_geolocated_default = require_dist_modules();
export {
  react_geolocated_default as default
};
//# sourceMappingURL=react-geolocated.js.map
